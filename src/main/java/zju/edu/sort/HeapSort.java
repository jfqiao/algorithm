package zju.edu.sort;

/**
 * 算法原理:
 *    堆的定义:堆分为最大堆和最小堆两种形式,定义类似,堆是一棵完全二叉树,根节点元素比左右子树上的元素都大则为最大堆
 *    否则称为最小堆.
 *    堆排序的算法原理是首先构造一个最大堆(以此得到非递减序列),然后将堆顶元素与堆底元素进行交换,然后调整堆顶元素,
 * 使得前n-1个元素仍是最大堆.持续进行这种调整,直到堆中只剩下一个元素位置,则数组有序.
 *    
 *    建堆算法:堆的顺序存储采用数组保存,利用位置表示节点之间的关系.
 *    建堆算法利用从叶子节点的父节点开始,不点通过调整局部子树为最大(小)堆,最终构成最大(小)堆.
 * 主要操作是ajustDown运算,即如果r+1到j这j-r个位置上的元素已经满足了堆的要求,那么增加一个元素r,
 * 运行此次操作后,使得仍满足堆的条件. 这个运算对于建堆操作十分重要,
 *    建堆的过程:首先叶子节点没有孩子节点,因此他们不用调整,就是符合条件的堆,所以调整元素的开始位置从有孩子节点的元素开始.
 * 对于有n个元素的堆,其非叶子节点数为n/2整除.由于数组下标从0开始,因此开始位置为(n-2)/2整除.
 *    
 * 空间复杂度:
 *   堆排序不需要额外的空间,也不会进行递归求解,因此空间复杂度是O(1)
 * 时间复杂度:
 *   堆排序时间复杂度:构造堆的时间复杂度为O(nlog[n]), 
 * 稳定性:
 *   堆排序是不稳定的排序,元素有横跨交换.
 * @author jfq
 *
 */

public class HeapSort {
    public static void heapSort(int[] nums) {
    	// 第一步: 构建最大堆
    	for (int i = (nums.length - 2) / 2; i > -1; i--)
    		adjust(nums, i, nums.length - 1);
    	for (int i = nums.length - 1; i > -1; i--) {
    		int tmp = nums[i];
    		nums[i] = nums[0];
    		nums[0] = tmp;
    		// 将堆顶元素与最后一个元素进行交换,所以最大元素移动到了数组的末尾
    		// 然后需要调整堆继续为最大堆,现在从1到i-1仍是最大堆,需要调整的位置是最新交换过来的堆顶元素,即0位置.
    		// i位置已经不需要调整了,i以及其以后的位置都已经是有序序列了.
    		adjust(nums, 0, i - 1);
    	}
    }
    
    private static void adjust(int[] nums, int r, int q) {
    	// 从r + 1到q符合堆的要求,增加r后调整堆使其仍然是最大堆.
    	// 比较r与其子节点较大的数,如果大于则直接返回,否则向下调整节点,与较大的子节点交换后继续进行比较,
        // 知道符合条件或者到达叶子节点.
    	int child = 2 * r + 1;
    	int curVal = nums[r];
    	while (child <= q) {
    		// 选择两个子节点中较大的子节点
    		if (child < q && nums[child] < nums[child + 1])
    			child += 1;
    		if (curVal > nums[child])   // 用一个变量记录需要调整的值,可以不用每次都进行交换,只需要比较即可.最后需要交换过来.
    			break;
    		nums[(child - 1) / 2] = nums[child];   // 将子节点的数值放到根节点处,然后继续向下调整, 此处不进行交换
    		child = child * 2 + 1;
    	}
    	nums[(child - 1) / 2] = curVal;
    }
}
